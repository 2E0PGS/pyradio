#!/usr/bin/env python

# TODO:
# Handle screen resize correctly
# Allow adding and removing of stations
# Allow muting/pausing of audio

import os
import sys
import curses
import thread
import subprocess

RESIZE_EVENT = False

stations = [
	("SomaFM: Groove Salad", "http://somafm.com/startstream=groovesalad.pls"),
	("SomaFM: Beat Blender", "http://somafm.com/startstream=beatblender.pls"),
	("SomaFM: Cliq Hop", "http://somafm.com/startstream=cliqhop.pls"),
	("SomaFM: Sonic Universe", "http://somafm.com/startstream=sonicuniverse.pls"),
	("Digitally Imported Chillout", "http://di.fm/mp3/chillout.pls"),
	("Secret Agent", "http://somafm.com/secretagent.pls"),
	("Slay Radio", "http://sc.slayradio.org:8000/listen.pls"),
	("Frequence 3", "http://streams.frequence3.net/hd-mp3.m3u"),
	("Smooth FM (Jazz)", "http://66.55.143.195:9028"),
	("Smooth Jazz Cafe", "http://64.72.125.3:8004"),
	("Virgin Radio", "http://www.smgradio.com/core/audio/mp3/live.pls?service=vrbb"),
]

class Log(object):
	def __init__(self, cursesScreen):	
		self.cursesScreen = cursesScreen
		self.width = cursesScreen.getmaxyx()[1] - 4
	def write(self, str):
		self.cursesScreen.erase()		
		self.cursesScreen.addstr(0, 1, str[0: self.width].replace("\r", "").replace("\n", ""))
		self.cursesScreen.refresh()

	def readline(self):
		pass

class Player(object):
	process = None
	def __init__(self, outputStream):
		self.outputStream = outputStream

	def updateStatus(self):
		try:
			input = self.process.stdout.readline()
			while(input != ''):
				self.outputStream.write(input)
				input = self.process.stdout.readline()
		except: pass

	def play(self, url):
		self.close()
		self.process = subprocess.Popen("mplayer %s -quiet" % url, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
		thread.start_new_thread(self.updateStatus, ())

	def close(self):
		if(self.process != None):
			try:
				self.process.stdin.write('q')
			except: pass
			self.process = None

class Interface(object):
	""" ncurses interface of the program """

	display_modes = ['']
	start_pos = 0
	selection = 0
	def __init__(self, args):
		self.test = 'this'

	def init_and_run(self, stdscr):
		""" called by ncurses.wrapper """
		self.stdscr = stdscr

		try:
			curses.curs_set(0)
		except:
			pass

		curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
		curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
		curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
		curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
		curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)
		curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_MAGENTA)
		curses.init_pair(7, curses.COLOR_BLACK, curses.COLOR_GREEN)

		self.max_y, self.max_x = stdscr.getmaxyx()

		self.head_win = curses.newwin(1, self.max_x, 0, 0)
		self.body_win = curses.newwin(self.max_y-2, self.max_x, 1, 0)
		self.footer_win = curses.newwin(1, self.max_x, self.max_y-1, 0)
		self.init_head_win()
		self.init_body_win()
		self.init_footer_win()

		self.log = Log(self.footer_win)
		self.player = Player(self.log)

		curses.doupdate()

		self.run()

	def init_head_win(self):
		""" Initializes the head/information window """
		info = " PyRadio 0.1 "
		self.head_win.addstr(0, 0, info, curses.color_pair(4))
		x = self.head_win.getyx()[1]
		rightStr = "www.plasis.co.uk/pyradio"
		self.head_win.addstr(0, self.max_x - len(rightStr) - 1, rightStr, curses.color_pair(2))
		self.head_win.bkgd(' ', curses.color_pair(7))
		self.head_win.noutrefresh()

	def init_body_win(self):
		""" Initializes the body/story window """
		self.body_win.timeout(100)
		self.body_win.keypad(1)
		self.body_max_y, self.body_max_x = self.body_win.getmaxyx()
#		wait_msg = "Loading stations"
#		self.body_win.addstr(self.body_max_y/2, self.body_max_x/2 - len(wait_msg)/2, wait_msg, curses.color_pair(3))
		self.body_win.box()
		self.body_win.noutrefresh()
		self.refreshBody()

	def init_footer_win(self):
		""" Initializes the body/story window """
		self.footer_max_y, self.body_footer_x = self.footer_win.getmaxyx()
#		self.body_win.addstr(self.body_max_y/2, self.body_max_x/2 - len(wait_msg)/2, wait_msg, curses.color_pair(3))
		self.footer_win.bkgd(' ', curses.color_pair(7))
		self.footer_win.noutrefresh()

	def refreshBody(self):
		self.body_win.erase()
		self.body_win.box()		
	
		self.body_win.move(1, 1)
		max_display = self.body_max_y
		for idx in range(max_display - 1):
			try:
				station = stations[idx + self.start_pos]
				col = curses.color_pair(5)
				if idx == self.selection: 
					col = curses.color_pair(6)
					self.body_win.hline(idx + 1, 1, ' ', self.body_max_x - 2, col)
				self.body_win.addstr(idx + 1, 1, station[0], col)

			except IndexError:
				break

	def resize(self):
		h, w = gethw()
		if not h:
			return

		curses.endwin()
		os.environ["LINES"] = str(h)
		os.environ["COLUMNS"] = str(w)

		self.body_max_y, self.body_max_x = self.body_win.getmaxyx()

		curses.doupdate()
		
	def run(self):
		global RESIZE_EVENT
		while True:
			try:
				if RESIZE_EVENT:
					RESIZE_EVENT = False
					self.resize()
				c = self.body_win.getch()	# getch() has a 100ms timeout
				ret = self.handle_keystroke(c)
				if (ret == -1): return
			except KeyboardInterrupt:
				break
			except curses.error, e:
				raise ProgError, "Curses Error: %s" % e

	def handle_keystroke(self, char):
		if char == curses.KEY_EXIT or char == ord('q'):
			self.player.close()			
			return -1

		elif char in (curses.KEY_ENTER, ord('\n'), ord('\r')):
			url = stations[self.selection][1]
			self.player.play(url)
			return
		elif char == curses.KEY_DOWN or char== ord('j'):
			if self.selection < len(stations) - 1:
				self.selection += 1
				self.refreshBody()
			return
		elif char == curses.KEY_UP or char == ord('k'):
			# Scroll stories up by one
			if self.selection > 0:
				self.selection -= 1
				self.refreshBody()
			return

if __name__ == "__main__":
		interface = Interface("")
		curses.wrapper(interface.init_and_run)
